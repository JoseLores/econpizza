# hank.yaml ---
#
# Description: a small example HANK model
# Author: Gregor Boehl [mail@gregorboehl.com]
# Last-Updated: 24/04/22

name: '1ahank'
functions_file: '../examples/hank_functions.py'

# these are available during all three stages (decisions, distributions, equations)
definitions:
    - from numpy import log
    - from jax.experimental.host_callback import id_print as jax_print

variables: [Div, Y, Yprod, w, pi, rn, r, rstar, Tax, Z, beta, vphi, C, L, B] # Yprod is actually produced output, Y is net of price adjustment costs  
distributions:
  D: # a distribution named 'D'
    # ordering matters because it is the same ordering as the axis of all distribution variables
    e: # dim0
      type: exogenous
      grid_variables: [e_grid, e_stationary, e_tmat] # returns e_grid, e_stationary, e_tmat
      rho: 0.966
      sigma: 0.5
      # alternatively: if the previous 3 are not defined here, it is assumed that the grid_variables are available during the distribution stage (as an output of 'decisions')
      n: 4
    a: # dim1
      type: endogenous
      grid_variables: a_grid # a variable named a_grid will be made available during decisions calls and distributions calls
      min: 0.0
      max: 150
      n: 10

decisions: # stage one
  inputs: [VaPrime] # additional to all aggregated variables defined in 'variables'
  calls:
    # these are executed subsequently, starting with the latest in time T. Each call takes the previous outputs as given
    ~ T = transfers(e_stationary, Div, Tax, e_grid)
    ~ we = wages(w, e_grid)
    ~ VaPrimeExp = e_tmat @ VaPrime
    ~ Va, a, c, n = hh(VaPrimeExp, a_grid, we, T, r-1, beta, eis, frisch, vphi)
    ~ ne = labor_supply(n, e_grid)
  outputs: [a,c,ne] # those are the ones stored for the following stages

# stage two: finding distributions via forward calls. This is done automatically using the information provided in 'distributions'
# inputs are all grid_variables and, for endogenous distribution variables, variables named like the members of 'distributions' (e.g. 'a')
# outputs are the distribution(s) named as define in 'distributions' (e.g. here 'D')

# stage three (optional): aux_equations
# these can contain misc definitions that are available during the final stage. 
# outputs from decisions, the grid variables, the distributions and 
# aggregate variables from 'variables' (including those with "Prime", "Lag",...) are included by default
# from here on the objects are _sequences_ with shapes either (1, horizon) or (n1, n2, horizon). Last dimension is always the time dimension
aux_equations:
    ~ A = np.sum(D*a, axis=(0,1)) # note that we are summing over the first two dimensions e and a, but not the time dimension (dimension 2)
    ~ NE = np.sum(D*ne, axis=(0,1))
    ~ Caggr = np.sum(D*c, axis=(0,1)) 

equations: # final stage
    ~ L = Yprod / Z
    ~ Div = - w * L + (1 - psi*(pi/piSS - 1)**2/2)*Yprod
    ~ C = (1 - psi*(pi/piSS - 1)**2/2)*Yprod
    ~ C = Y
    ~ C = Caggr
    ~ psi*(pi/piSS - 1)*pi/piSS = (1-theta) + theta*w + psi*betaPrime*C/CPrime*(piPrime/piSS - 1)*piPrime/piSS*YprodPrime/Yprod
    ~ r = rnLag/pi
    ~ rn = (rstar*((pi/piSS)**phi_pi)*((Y/YLag)**phi_y))**(1-rho)*rnLag**rho
    ~ Tax = (r-1) * B
    ~ B = A
    ~ NE = L
    ~ vphi = vphiSS # actually a parameter
    ~ beta = betaSS*(betaLag/betaSS)**rho_beta
    ~ rstar = rstarSS*(rstarLag/rstarSS)**rho_rstar
    ~ Z = ZSS*(ZLag/ZSS)**rho_Z

parameters:
    eis: 0.5
    frisch: 0.5
    rho_e: 0.966
    sd_e: 0.5
    mu: 1.2
    theta: 6.
    psi: 96
    phi_pi: 2
    phi_y: 1.5
    rho: .8
    rho_beta: .8
    rho_rstar: .8
    rho_Z: .8

steady_state:
    fixed_values:
        Y: 1.0
        Z: 1.0
        pi: 1.0
        rstar: 1.005
        B: 5.6
        L: 1.0

    init_guesses:
        beta: 0.98
        vphi: 0.8
        w: 1/1.2
        Div: 1 - 1/1.2
        Tax: 0.028
        r: 1.005
        we: wages(w, e_grid)
        T: transfers(e_stationary, Div, Tax, e_grid)
        VaPrime: hh_init(a_grid, we, r, eis, T)[1]
